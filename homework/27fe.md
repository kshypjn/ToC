1. Simulating a Deterministic Turing Machine (TM) with a RAM

Suppose we have a simple Turing machine $M$. At any time, $M$ is described by:
- Its current state ($q$)
- What's on its tape
- Where its head is ($h$)

To represent this with a RAM (Random Access Machine):
- Each tape cell is stored at a memory address (for example, tape cell $i$ is at memory cell $i$).
- The head’s current position is saved in a register, say $H$.
- The current TM state is saved in another register, say $Q$.

To simulate a step:
1. Load the tape symbol at the head (use $H$ to access this in memory).
2. Look up the TM’s rule (given $Q$ and the loaded symbol) to get the new state, new symbol to write, and which way to move the head.
3. Write the new symbol into tape (memory at $H$).
4. Update the head position ($H$ increases, decreases, or stays the same).
5. Update the state register ($Q$).

Each Turing machine step only needs a small, fixed number of RAM instructions. So, a RAM can easily simulate a TM, step by step and produce the same output.

2. Simulating a RAM with a Deterministic Turing Machine

Now suppose we have a RAM program $P$. At any step, the RAM’s situation can be described by:
- Which instruction it’s about to do
- The values of its registers
- The values in memory cells it's used so far (the rest are ignored)

A Turing machine can write all this as a string on its tape, separated by special symbols:
- The instruction number
- Register values
- List of memory addresses (used so far) and what’s stored there

To simulate RAM’s instructions, the TM does the following (sometimes needing several moves):
1. To change a register value, TM scans tape to find the register and updates its value.
2. To load or store a memory cell, TM finds the right address among those listed, or adds it if it’s new, and changes the value where needed.
3. For jumping/branching, TM checks register values and updates the current instruction number accordingly.

Each RAM step may take many TM moves, but every RAM instruction can be broken down like this.

Therefore, for any RAM program, there’s a Turing machine that simulates it correctly and halts with the same result.
