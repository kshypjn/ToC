### Construction Algorithm

Input: DFA M = (Q, Σ, δ, q₀, F)
Output: DFA M' accepting reverse(L)
Steps:

1. Reverse the DFA to get an NFA:
   - Start states: F (all accept states of M become start states)
   - Accept state: {q₀} (the original start state becomes the accept state)
   - Transitions: For each transition δ(q, a) = p in M, add transition from p to q on symbol a
   
   This gives us NFA N = (Q, Σ, δ_reverse, F, {q₀}) where:
   - δ_reverse(p, a) = {q | δ(q, a) = p}

2. Convert NFA to DFA using subset construction:
   - States of M': 2^Q (subsets of Q)
   - Start state: F (set of all accept states from M)
   - Accept states: All subsets containing q₀
   - Transition function: δ'(S, a) = ⋃_{q∈S} δ_reverse(q, a)

### Complexity
- Original DFA has n states
- Reversed NFA has n states  
- After subset construction: DFA may have up to **2^n states**

---
### Family of Languages L_n

construct a family of languages {L_n | n ≥ 1} where:
- L_n has a DFA with O(n) states
- Any DFA for reverse(L_n) requires at least 2^n states

### Construction of L_n

Alphabet: Σ = {0, 1}

Language Definition:
```
L_n = {w ∈ {0,1}* | the n-th symbol from the END is 1}
```

L_n accepts all strings where the n-th position from the right is 1.

Examples for n=2
- L₂ accepts: 10, 11, 100, 101, 110, 111, 1000, 1001, ...
- L₂ rejects: ε, 0, 1, 00, 01, 000, 001, 010, 011, ...

### DFA for L_n (O(n) states)

1. Read the first n-1 symbols 
2. Check that the n-th symbol is 1
3. Accept anything after that

**States:** {q₀, q₁, q₂, ..., qₙ₋₁, qₙ, q_reject}

**Transitions:**
```
δ(qᵢ, 0) = qᵢ₊₁ for i < n-1
δ(qᵢ, 1) = qᵢ₊₁ for i < n-1
δ(qₙ₋₁, 1) = qₙ (we see 1 at position n)
δ(qₙ₋₁, 0) = q_reject (we see 0 at position n)
δ(qₙ, 0) = qₙ (accept everything after)
δ(qₙ, 1) = qₙ
δ(q_reject, 0) = q_reject
δ(q_reject, 1) = q_reject
```

Start state: q₀  
Accept state: qₙ

This DFA has **n+2 = O(n) states**.
